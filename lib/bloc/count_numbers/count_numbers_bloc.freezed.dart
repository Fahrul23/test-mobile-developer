// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'count_numbers_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CountNumbersEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(int input) countFirst,
    required TResult Function(int input) countSecond,
    required TResult Function(int input) countThird,
    required TResult Function(int input) countFourth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(int input)? countFirst,
    TResult? Function(int input)? countSecond,
    TResult? Function(int input)? countThird,
    TResult? Function(int input)? countFourth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(int input)? countFirst,
    TResult Function(int input)? countSecond,
    TResult Function(int input)? countThird,
    TResult Function(int input)? countFourth,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_CountFirst value) countFirst,
    required TResult Function(_CountSecound value) countSecond,
    required TResult Function(_CountThird value) countThird,
    required TResult Function(_CountFourth value) countFourth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_CountFirst value)? countFirst,
    TResult? Function(_CountSecound value)? countSecond,
    TResult? Function(_CountThird value)? countThird,
    TResult? Function(_CountFourth value)? countFourth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_CountFirst value)? countFirst,
    TResult Function(_CountSecound value)? countSecond,
    TResult Function(_CountThird value)? countThird,
    TResult Function(_CountFourth value)? countFourth,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CountNumbersEventCopyWith<$Res> {
  factory $CountNumbersEventCopyWith(
          CountNumbersEvent value, $Res Function(CountNumbersEvent) then) =
      _$CountNumbersEventCopyWithImpl<$Res, CountNumbersEvent>;
}

/// @nodoc
class _$CountNumbersEventCopyWithImpl<$Res, $Val extends CountNumbersEvent>
    implements $CountNumbersEventCopyWith<$Res> {
  _$CountNumbersEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$CountNumbersEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StartedImpl implements _Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'CountNumbersEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(int input) countFirst,
    required TResult Function(int input) countSecond,
    required TResult Function(int input) countThird,
    required TResult Function(int input) countFourth,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(int input)? countFirst,
    TResult? Function(int input)? countSecond,
    TResult? Function(int input)? countThird,
    TResult? Function(int input)? countFourth,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(int input)? countFirst,
    TResult Function(int input)? countSecond,
    TResult Function(int input)? countThird,
    TResult Function(int input)? countFourth,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_CountFirst value) countFirst,
    required TResult Function(_CountSecound value) countSecond,
    required TResult Function(_CountThird value) countThird,
    required TResult Function(_CountFourth value) countFourth,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_CountFirst value)? countFirst,
    TResult? Function(_CountSecound value)? countSecond,
    TResult? Function(_CountThird value)? countThird,
    TResult? Function(_CountFourth value)? countFourth,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_CountFirst value)? countFirst,
    TResult Function(_CountSecound value)? countSecond,
    TResult Function(_CountThird value)? countThird,
    TResult Function(_CountFourth value)? countFourth,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements CountNumbersEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$CountFirstImplCopyWith<$Res> {
  factory _$$CountFirstImplCopyWith(
          _$CountFirstImpl value, $Res Function(_$CountFirstImpl) then) =
      __$$CountFirstImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int input});
}

/// @nodoc
class __$$CountFirstImplCopyWithImpl<$Res>
    extends _$CountNumbersEventCopyWithImpl<$Res, _$CountFirstImpl>
    implements _$$CountFirstImplCopyWith<$Res> {
  __$$CountFirstImplCopyWithImpl(
      _$CountFirstImpl _value, $Res Function(_$CountFirstImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
  }) {
    return _then(_$CountFirstImpl(
      null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$CountFirstImpl implements _CountFirst {
  const _$CountFirstImpl(this.input);

  @override
  final int input;

  @override
  String toString() {
    return 'CountNumbersEvent.countFirst(input: $input)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CountFirstImpl &&
            (identical(other.input, input) || other.input == input));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CountFirstImplCopyWith<_$CountFirstImpl> get copyWith =>
      __$$CountFirstImplCopyWithImpl<_$CountFirstImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(int input) countFirst,
    required TResult Function(int input) countSecond,
    required TResult Function(int input) countThird,
    required TResult Function(int input) countFourth,
  }) {
    return countFirst(input);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(int input)? countFirst,
    TResult? Function(int input)? countSecond,
    TResult? Function(int input)? countThird,
    TResult? Function(int input)? countFourth,
  }) {
    return countFirst?.call(input);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(int input)? countFirst,
    TResult Function(int input)? countSecond,
    TResult Function(int input)? countThird,
    TResult Function(int input)? countFourth,
    required TResult orElse(),
  }) {
    if (countFirst != null) {
      return countFirst(input);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_CountFirst value) countFirst,
    required TResult Function(_CountSecound value) countSecond,
    required TResult Function(_CountThird value) countThird,
    required TResult Function(_CountFourth value) countFourth,
  }) {
    return countFirst(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_CountFirst value)? countFirst,
    TResult? Function(_CountSecound value)? countSecond,
    TResult? Function(_CountThird value)? countThird,
    TResult? Function(_CountFourth value)? countFourth,
  }) {
    return countFirst?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_CountFirst value)? countFirst,
    TResult Function(_CountSecound value)? countSecond,
    TResult Function(_CountThird value)? countThird,
    TResult Function(_CountFourth value)? countFourth,
    required TResult orElse(),
  }) {
    if (countFirst != null) {
      return countFirst(this);
    }
    return orElse();
  }
}

abstract class _CountFirst implements CountNumbersEvent {
  const factory _CountFirst(final int input) = _$CountFirstImpl;

  int get input;
  @JsonKey(ignore: true)
  _$$CountFirstImplCopyWith<_$CountFirstImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CountSecoundImplCopyWith<$Res> {
  factory _$$CountSecoundImplCopyWith(
          _$CountSecoundImpl value, $Res Function(_$CountSecoundImpl) then) =
      __$$CountSecoundImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int input});
}

/// @nodoc
class __$$CountSecoundImplCopyWithImpl<$Res>
    extends _$CountNumbersEventCopyWithImpl<$Res, _$CountSecoundImpl>
    implements _$$CountSecoundImplCopyWith<$Res> {
  __$$CountSecoundImplCopyWithImpl(
      _$CountSecoundImpl _value, $Res Function(_$CountSecoundImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
  }) {
    return _then(_$CountSecoundImpl(
      null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$CountSecoundImpl implements _CountSecound {
  const _$CountSecoundImpl(this.input);

  @override
  final int input;

  @override
  String toString() {
    return 'CountNumbersEvent.countSecond(input: $input)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CountSecoundImpl &&
            (identical(other.input, input) || other.input == input));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CountSecoundImplCopyWith<_$CountSecoundImpl> get copyWith =>
      __$$CountSecoundImplCopyWithImpl<_$CountSecoundImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(int input) countFirst,
    required TResult Function(int input) countSecond,
    required TResult Function(int input) countThird,
    required TResult Function(int input) countFourth,
  }) {
    return countSecond(input);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(int input)? countFirst,
    TResult? Function(int input)? countSecond,
    TResult? Function(int input)? countThird,
    TResult? Function(int input)? countFourth,
  }) {
    return countSecond?.call(input);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(int input)? countFirst,
    TResult Function(int input)? countSecond,
    TResult Function(int input)? countThird,
    TResult Function(int input)? countFourth,
    required TResult orElse(),
  }) {
    if (countSecond != null) {
      return countSecond(input);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_CountFirst value) countFirst,
    required TResult Function(_CountSecound value) countSecond,
    required TResult Function(_CountThird value) countThird,
    required TResult Function(_CountFourth value) countFourth,
  }) {
    return countSecond(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_CountFirst value)? countFirst,
    TResult? Function(_CountSecound value)? countSecond,
    TResult? Function(_CountThird value)? countThird,
    TResult? Function(_CountFourth value)? countFourth,
  }) {
    return countSecond?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_CountFirst value)? countFirst,
    TResult Function(_CountSecound value)? countSecond,
    TResult Function(_CountThird value)? countThird,
    TResult Function(_CountFourth value)? countFourth,
    required TResult orElse(),
  }) {
    if (countSecond != null) {
      return countSecond(this);
    }
    return orElse();
  }
}

abstract class _CountSecound implements CountNumbersEvent {
  const factory _CountSecound(final int input) = _$CountSecoundImpl;

  int get input;
  @JsonKey(ignore: true)
  _$$CountSecoundImplCopyWith<_$CountSecoundImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CountThirdImplCopyWith<$Res> {
  factory _$$CountThirdImplCopyWith(
          _$CountThirdImpl value, $Res Function(_$CountThirdImpl) then) =
      __$$CountThirdImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int input});
}

/// @nodoc
class __$$CountThirdImplCopyWithImpl<$Res>
    extends _$CountNumbersEventCopyWithImpl<$Res, _$CountThirdImpl>
    implements _$$CountThirdImplCopyWith<$Res> {
  __$$CountThirdImplCopyWithImpl(
      _$CountThirdImpl _value, $Res Function(_$CountThirdImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
  }) {
    return _then(_$CountThirdImpl(
      null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$CountThirdImpl implements _CountThird {
  const _$CountThirdImpl(this.input);

  @override
  final int input;

  @override
  String toString() {
    return 'CountNumbersEvent.countThird(input: $input)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CountThirdImpl &&
            (identical(other.input, input) || other.input == input));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CountThirdImplCopyWith<_$CountThirdImpl> get copyWith =>
      __$$CountThirdImplCopyWithImpl<_$CountThirdImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(int input) countFirst,
    required TResult Function(int input) countSecond,
    required TResult Function(int input) countThird,
    required TResult Function(int input) countFourth,
  }) {
    return countThird(input);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(int input)? countFirst,
    TResult? Function(int input)? countSecond,
    TResult? Function(int input)? countThird,
    TResult? Function(int input)? countFourth,
  }) {
    return countThird?.call(input);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(int input)? countFirst,
    TResult Function(int input)? countSecond,
    TResult Function(int input)? countThird,
    TResult Function(int input)? countFourth,
    required TResult orElse(),
  }) {
    if (countThird != null) {
      return countThird(input);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_CountFirst value) countFirst,
    required TResult Function(_CountSecound value) countSecond,
    required TResult Function(_CountThird value) countThird,
    required TResult Function(_CountFourth value) countFourth,
  }) {
    return countThird(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_CountFirst value)? countFirst,
    TResult? Function(_CountSecound value)? countSecond,
    TResult? Function(_CountThird value)? countThird,
    TResult? Function(_CountFourth value)? countFourth,
  }) {
    return countThird?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_CountFirst value)? countFirst,
    TResult Function(_CountSecound value)? countSecond,
    TResult Function(_CountThird value)? countThird,
    TResult Function(_CountFourth value)? countFourth,
    required TResult orElse(),
  }) {
    if (countThird != null) {
      return countThird(this);
    }
    return orElse();
  }
}

abstract class _CountThird implements CountNumbersEvent {
  const factory _CountThird(final int input) = _$CountThirdImpl;

  int get input;
  @JsonKey(ignore: true)
  _$$CountThirdImplCopyWith<_$CountThirdImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CountFourthImplCopyWith<$Res> {
  factory _$$CountFourthImplCopyWith(
          _$CountFourthImpl value, $Res Function(_$CountFourthImpl) then) =
      __$$CountFourthImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int input});
}

/// @nodoc
class __$$CountFourthImplCopyWithImpl<$Res>
    extends _$CountNumbersEventCopyWithImpl<$Res, _$CountFourthImpl>
    implements _$$CountFourthImplCopyWith<$Res> {
  __$$CountFourthImplCopyWithImpl(
      _$CountFourthImpl _value, $Res Function(_$CountFourthImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
  }) {
    return _then(_$CountFourthImpl(
      null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$CountFourthImpl implements _CountFourth {
  const _$CountFourthImpl(this.input);

  @override
  final int input;

  @override
  String toString() {
    return 'CountNumbersEvent.countFourth(input: $input)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CountFourthImpl &&
            (identical(other.input, input) || other.input == input));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CountFourthImplCopyWith<_$CountFourthImpl> get copyWith =>
      __$$CountFourthImplCopyWithImpl<_$CountFourthImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(int input) countFirst,
    required TResult Function(int input) countSecond,
    required TResult Function(int input) countThird,
    required TResult Function(int input) countFourth,
  }) {
    return countFourth(input);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(int input)? countFirst,
    TResult? Function(int input)? countSecond,
    TResult? Function(int input)? countThird,
    TResult? Function(int input)? countFourth,
  }) {
    return countFourth?.call(input);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(int input)? countFirst,
    TResult Function(int input)? countSecond,
    TResult Function(int input)? countThird,
    TResult Function(int input)? countFourth,
    required TResult orElse(),
  }) {
    if (countFourth != null) {
      return countFourth(input);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_CountFirst value) countFirst,
    required TResult Function(_CountSecound value) countSecond,
    required TResult Function(_CountThird value) countThird,
    required TResult Function(_CountFourth value) countFourth,
  }) {
    return countFourth(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_CountFirst value)? countFirst,
    TResult? Function(_CountSecound value)? countSecond,
    TResult? Function(_CountThird value)? countThird,
    TResult? Function(_CountFourth value)? countFourth,
  }) {
    return countFourth?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_CountFirst value)? countFirst,
    TResult Function(_CountSecound value)? countSecond,
    TResult Function(_CountThird value)? countThird,
    TResult Function(_CountFourth value)? countFourth,
    required TResult orElse(),
  }) {
    if (countFourth != null) {
      return countFourth(this);
    }
    return orElse();
  }
}

abstract class _CountFourth implements CountNumbersEvent {
  const factory _CountFourth(final int input) = _$CountFourthImpl;

  int get input;
  @JsonKey(ignore: true)
  _$$CountFourthImplCopyWith<_$CountFourthImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CountNumbersState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<int> numbers) loaded,
    required TResult Function(List<String> numbers) loadedToString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(List<int> numbers)? loaded,
    TResult? Function(List<String> numbers)? loadedToString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<int> numbers)? loaded,
    TResult Function(List<String> numbers)? loadedToString,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_LoadedToString value) loadedToString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_LoadedToString value)? loadedToString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_LoadedToString value)? loadedToString,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CountNumbersStateCopyWith<$Res> {
  factory $CountNumbersStateCopyWith(
          CountNumbersState value, $Res Function(CountNumbersState) then) =
      _$CountNumbersStateCopyWithImpl<$Res, CountNumbersState>;
}

/// @nodoc
class _$CountNumbersStateCopyWithImpl<$Res, $Val extends CountNumbersState>
    implements $CountNumbersStateCopyWith<$Res> {
  _$CountNumbersStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$CountNumbersStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'CountNumbersState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<int> numbers) loaded,
    required TResult Function(List<String> numbers) loadedToString,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(List<int> numbers)? loaded,
    TResult? Function(List<String> numbers)? loadedToString,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<int> numbers)? loaded,
    TResult Function(List<String> numbers)? loadedToString,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_LoadedToString value) loadedToString,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_LoadedToString value)? loadedToString,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_LoadedToString value)? loadedToString,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements CountNumbersState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int> numbers});
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$CountNumbersStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numbers = null,
  }) {
    return _then(_$LoadedImpl(
      null == numbers
          ? _value._numbers
          : numbers // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc

class _$LoadedImpl implements _Loaded {
  const _$LoadedImpl(final List<int> numbers) : _numbers = numbers;

  final List<int> _numbers;
  @override
  List<int> get numbers {
    if (_numbers is EqualUnmodifiableListView) return _numbers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_numbers);
  }

  @override
  String toString() {
    return 'CountNumbersState.loaded(numbers: $numbers)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality().equals(other._numbers, _numbers));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_numbers));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<int> numbers) loaded,
    required TResult Function(List<String> numbers) loadedToString,
  }) {
    return loaded(numbers);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(List<int> numbers)? loaded,
    TResult? Function(List<String> numbers)? loadedToString,
  }) {
    return loaded?.call(numbers);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<int> numbers)? loaded,
    TResult Function(List<String> numbers)? loadedToString,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(numbers);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_LoadedToString value) loadedToString,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_LoadedToString value)? loadedToString,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_LoadedToString value)? loadedToString,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements CountNumbersState {
  const factory _Loaded(final List<int> numbers) = _$LoadedImpl;

  List<int> get numbers;
  @JsonKey(ignore: true)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadedToStringImplCopyWith<$Res> {
  factory _$$LoadedToStringImplCopyWith(_$LoadedToStringImpl value,
          $Res Function(_$LoadedToStringImpl) then) =
      __$$LoadedToStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> numbers});
}

/// @nodoc
class __$$LoadedToStringImplCopyWithImpl<$Res>
    extends _$CountNumbersStateCopyWithImpl<$Res, _$LoadedToStringImpl>
    implements _$$LoadedToStringImplCopyWith<$Res> {
  __$$LoadedToStringImplCopyWithImpl(
      _$LoadedToStringImpl _value, $Res Function(_$LoadedToStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numbers = null,
  }) {
    return _then(_$LoadedToStringImpl(
      null == numbers
          ? _value._numbers
          : numbers // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$LoadedToStringImpl implements _LoadedToString {
  const _$LoadedToStringImpl(final List<String> numbers) : _numbers = numbers;

  final List<String> _numbers;
  @override
  List<String> get numbers {
    if (_numbers is EqualUnmodifiableListView) return _numbers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_numbers);
  }

  @override
  String toString() {
    return 'CountNumbersState.loadedToString(numbers: $numbers)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedToStringImpl &&
            const DeepCollectionEquality().equals(other._numbers, _numbers));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_numbers));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedToStringImplCopyWith<_$LoadedToStringImpl> get copyWith =>
      __$$LoadedToStringImplCopyWithImpl<_$LoadedToStringImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<int> numbers) loaded,
    required TResult Function(List<String> numbers) loadedToString,
  }) {
    return loadedToString(numbers);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(List<int> numbers)? loaded,
    TResult? Function(List<String> numbers)? loadedToString,
  }) {
    return loadedToString?.call(numbers);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<int> numbers)? loaded,
    TResult Function(List<String> numbers)? loadedToString,
    required TResult orElse(),
  }) {
    if (loadedToString != null) {
      return loadedToString(numbers);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_LoadedToString value) loadedToString,
  }) {
    return loadedToString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_LoadedToString value)? loadedToString,
  }) {
    return loadedToString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_LoadedToString value)? loadedToString,
    required TResult orElse(),
  }) {
    if (loadedToString != null) {
      return loadedToString(this);
    }
    return orElse();
  }
}

abstract class _LoadedToString implements CountNumbersState {
  const factory _LoadedToString(final List<String> numbers) =
      _$LoadedToStringImpl;

  List<String> get numbers;
  @JsonKey(ignore: true)
  _$$LoadedToStringImplCopyWith<_$LoadedToStringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
